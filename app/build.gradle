/**
 * The first line in the build configuration applies the Android plugin for
 * Gradle to this build and makes the android block available to specify
 * Android-specific build options.
 */
plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'kotlin-parcelize'
    id 'com.google.protobuf'
id 'kotlin-kapt'
}
import com.android.build.OutputFile
/**
 * The android block is where you configure all your Android-specific
 * build options.
 */
android {
    /**
     * 编译app所用的版本,应该使用最新的版本来编译,保证新功能的实现,同时要注意旧版本的兼容问题
     * compileSdkVersion specifies the Android API level Gradle should use to
     * compile your app. This means your app can use the API features included in
     * this API level and lower.
     *
     * Use the following syntax to access properties you define at the project level:
     * rootProject.ext.property_name
     */
    compileSdkVersion rootProject.ext.android.compileSdkVersion
    /**
     * buildToolsVersion specifies the version of the SDK build tools, command-line
     * utilities, and compiler that Gradle should use to build your app. You need to
     * download the build tools using the SDK Manager.
     *
     * This property is optional because the plugin uses a recommended version of
     * the build tools by default.
     */
    buildToolsVersion "30.0.3"

    /**
     * The defaultConfig block encapsulates default settings and entries for all
     * build variants, and can override some attributes in main/AndroidManifest.xml
     * dynamically[动态的] from the build system. You can configure product flavors[风味] to override
     * these values for different versions of your app.
     * 每个 Android 应用均有一个唯一的应用 ID，像 Java 软件包名称一样，例如 com.example.myapp。
     */
    defaultConfig {
        /**
         * applicationId uniquely identifies the package for publishing.[应用标识]
         * However, your source code should still reference the package name
         * defined by the package attribute in the main/AndroidManifest.xml file.
         * 在AndroidManifest.xml下依然要设置package="com.example.mydemowithjni"
         * 此 ID 可以在设备上和 Google Play 商店中对您的应用进行唯一标识。如果您要上传新版本的应用，
         * 应用 ID（以及用于为其签名的证书）必须与原始 APK 相同。如果您更改了应用 ID，
         * Google Play 商店会将该 APK 视为完全不同的应用。因此，发布您的应用后，绝不应更改应用 ID。
         *
         * applicationId和packgename是两码事,只是默认情况下applicationId和packgename相同
         *
         * **-----命名规则-----**
         * 必须至少包含两段（一个或多个圆点）。
         * 每段必须以字母开头。
         * 所有字符必须为字母数字或下划线 [a-zA-Z0-9_]。
         *
         * !!!Context.getPackageName() 方法会返回您的应用 ID,而不是包名
         */
        applicationId "com.example.mydemowithjni"
        // Defines the minimum API level required to run the app.
        minSdkVersion rootProject.ext.android.minSdkVersion
        // Specifies the API level used to test the app.
        targetSdkVersion rootProject.ext.android.targetSdkVersion
        versionName rootProject.ext.android.versionName
        // Defines a user-friendly version name for your app.[用户可见的版本名称]
        versionCode rootProject.ext.android.versionCode

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        externalNativeBuild {
            cmake {
                cppFlags ""
            }
        }
    }

    //配置签名信息
    signingConfigs {
        //在对应的buildType中进行引用
        release {
            storeFile file("myreleasekey.keystore")
            storePassword "password"
            keyAlias "MyReleaseKey"
            keyPassword "password"

            //从环境变量中获取密码
//            storePassword System.getenv("KSTOREPWD")
//            keyPassword System.getenv("KEYPWD")

            //让构建流程在您要从命令行调用 build 时提示您输入这些密码
//            storePassword System.console().readLine("\nKeystore password: ")
//            keyPassword System.console().readLine("\nKey password: ")

        }
    }

    // 为每个不同的apk自动设置versioncode
    // Map for the version code that gives each ABI a value.
    ext.abiCodes = ['armeabi-v7a':1, x86:2, x86_64:3]
    // For per-density APKs, create a similar map like this:
    // ext.densityCodes = ['mdpi': 1, 'hdpi': 2, 'xhdpi': 3]

    // For each APK output variant, override versionCode with a combination of
    // ext.abiCodes * 1000 + variant.versionCode. In this example, variant.versionCode
    // is equal to defaultConfig.versionCode. If you configure product flavors that
    // define their own versionCode, variant.versionCode uses that value instead.
    /* android.applicationVariants.all { variant ->

        // Assigns a different version code for each output APK
        // other than the universal APK.
        variant.outputs.each { output ->

            // Stores the value of ext.abiCodes that is associated with the ABI for this variant.
            def baseAbiVersionCode =
                    // Determines the ABI for this variant and returns the mapped value.
                    project.ext.abiCodes.get(output.getFilter(OutputFile.ABI))

            // Because abiCodes.get() returns null for ABIs that are not mapped by ext.abiCodes,
            // the following code does not override the version code for universal APKs.
            // However, because we want universal APKs to have the lowest version code,
            // this outcome is desirable.
            if (baseAbiVersionCode != null) {

                // Assigns the new version code to versionCodeOverride, which changes the version code
                // for only the output APK, not for the variant itself. Skipping this step simply
                // causes Gradle to use the value of variant.versionCode for the APK.
                output.versionCodeOverride =
                        baseAbiVersionCode * 1000 + variant.versionCode
            }
        }
    } */

    /**
     * The buildTypes block is where you can configure multiple build types.
     * By default, the build system defines two build types: debug and release.
     * The debug build type is not explicitly shown in the default build configuration,
     * but it includes debugging tools and is signed with the debug key.
     * The release build type applies Proguard settings and is not signed by default.
     */
    buildTypes {
        debug {
            //阻止 Crashlytics 自动更新其 build ID
            ext.alwaysUpdateBuildId = false
            //单独设置debug的应用ID
            applicationIdSuffix ".debug"
            debuggable true

            // Use static values for incremental builds to ensure that
            // resource files and BuildConfig aren't rebuilt with each run.
            // If these rebuild dynamically[动态的], they can interfere with
            // Apply Changes as well as Gradle UP-TO-DATE checks."\"${minutesSinceEpoch}\""
            // field类型:String, 名称: BUILD_TIME, 值:0
            //调用:  Log.i(TAG, BuildConfig.BUILD_TIME)
            buildConfigField("String", "BUILD_TIME", "\"0\"")
            //调用:  Log.i(TAG, getString(R.string.build_time))
            resValue("string", "build_time", "0")
        }
        release {
            // Enables code shrinking[压缩] for the release build type.
            // obfuscation, and optimization for only your project's release build type.
            // 这些编译时优化功能会增加项目的构建时间，而且如果您没有充分自定义要保留的代码，还可能会引入错误。
            // 因此，在构建应用的最终版本（也就是在发布应用之前测试的版本）时，最好启用这些编译时任务
            minifyEnabled true

            // 只有在开启了代码压缩之后,资源压缩才会效果更明显,因为处理无效代码后可能会有更多的资源变为无用资源
            // Enables resource shrinking, which is performed by the Android Gradle plugin.
            shrinkResources true

            // Includes the default ProGuard rules files that are packaged with
            // the Android Gradle plugin. To learn more, go to the section about
            // R8 configuration files.
            // proguard-android-optimize.txt  Android的通用规则, 由 Android Gradle 插件在编译时生成。
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'

            /*自定义要保留的资源
            如果您有想要保留或舍弃的特定资源，请在项目中创建一个包含 <resources> 标记的 XML 文件，
            并在 tools:keep 属性中指定每个要保留的资源，在 tools:discard 属性中指定每个要舍弃的资源。
            这两个属性都接受以逗号分隔的资源名称列表。您可以将星号字符用作通配符。
             */

            //引用签名配置
            signingConfig signingConfigs.release

            // 使用 buildConfigField() 方法将自定义字段添加到 BuildConfig 类中，然后在应用的运行时代码中访问这些值
            // These values are defined only for the release build, which
            // is typically used for full builds and continuous builds.
            buildConfigField("String", "BUILD_TIME", "\"0\"")
            resValue("string", "build_time", "1")
        }

        /**
         * The `initWith` property allows you to copy configurations from other build types,
         * then configure only the settings you want to change. This one copies the debug build
         * type, and then changes the manifest placeholder and application ID.
         */
//        staging {
//            initWith debug
//            manifestPlaceholders = [hostName: "internal.example.com"]
//            applicationIdSuffix ".debugStaging"
//            buildConfigField("String", "BUILD_TIME", "\"0\"")
//            resValue("string", "build_time", "2")
//        }
    }

    /**
     * The productFlavors block is where you can configure multiple product flavors.
     * This allows you to create different versions of your app that can
     * override the defaultConfig block with their own settings.
     * Product flavors are optional, and the build system does not create them by default.
     *
     * This example creates a free and paid product flavor. Each product flavor
     * then specifies its own application ID, so that they can exist on the Google
     * Play Store, or an Android device, simultaneously[同时的].
     *
     * If you declare product flavors, you must also declare flavor dimensions
     * and assign each flavor to a flavor dimension[flavor和dimension一一对应].
     *
     * 在flavorDimensions中定义的dimension都需要在productFlavors中使用到,不然会报错
     * Android Studio: No build variant found error
     *
     * 所有变种都必须属于一个指定的变种维度，即一个产品变种组。您必须将所有变种分配给某个变种维度；
     * 否则，您将收到如下所示的构建错误。如果给定的模块仅指定一个变种维度，那么 Android Gradle
     * 插件会自动将该模块的所有变种分配给该维度。
     *
     * https://stackoverflow.com/questions/64366729/android-studio-no-build-variant-found-error/66550755#66550755?newreg=d77c3adbb99d400c9267e075365601e6
     *
     * Gradle 创建的 build 变体数量等于每个变种维度中的变种数量与您配置的 build 类型数量的乘积。
     * 2 * 2 * 2 *3
     * 三个维度['api', 'abi', 'version'],每个维度中的变种数量[目前都是2]相乘,再乘以buildType种类[3]
     */
//    flavorDimensions('api', 'abi', 'version')
    productFlavors {
//        x86 {
//            dimension 'abi'
////            applicationId 'com.example.mydemowithjni.x86'
//            //在默认的应用id名添加后缀
//            applicationIdSuffix '.x86'
//            //配置差异化的logo和app名字,需要在AndroidManifest中进行修改
//            manifestPlaceholders = [
//                    logo   : "@mipmap/ic_launcher_round",
//                    appName: "x86",
//            ]
//            // The following configuration limits the "dev" flavor to using
//            // English stringresources and xxhdpi screen-density resources.
//            // 避免编译和打包不测试的资源
//            resConfigs "en", "xxhdpi"
//
//            versionNameSuffix "-x86"
//            // 配置签名
//            //signingConfig signingConfigs.jiangpengyong
//        }
//        x64 {
//            dimension 'abi'
//            applicationIdSuffix '.x64'
//            //配置差异化的logo和app名字,需要在AndroidManifest中进行修改
//            manifestPlaceholders = [
//                    logo   : "@mipmap/ic_launcher_round",
//                    appName: "x64",
//            ]
//        }
//        demo {
//            dimension 'version'
//            applicationIdSuffix '.demo'
//            //配置差异化的logo和app名字,需要在AndroidManifest中进行修改
//            manifestPlaceholders = [
//                    logo   : "@mipmap/ic_launcher_round",
//                    appName: "demo",
//            ]
//            //添加自定义的混淆规则文件
//            proguardFile 'demo-rules.pro'
//        }
//        full {
//            dimension 'version'
//            applicationIdSuffix '.full'
//            //配置差异化的logo和app名字,需要在AndroidManifest中进行修改
//            manifestPlaceholders = [
//                    logo   : "@mipmap/ic_launcher_round",
//                    appName: "full",
//            ]
//        }

        // Configurations in the "api" product flavors override those in "mode"
        // flavors and the defaultConfig block. Gradle determines[确定] the priority
        // between flavor dimensions based on the order in which they appear next
        // to the flavorDimensions property above
        // --the first dimension has a higher priority than the second, and so on.
//        minApi23 {
//            dimension "api"
//            minSdkVersion 23
//            versionCode 20000 + android.defaultConfig.versionCode
//            versionNameSuffix "-minApi23"
//        }
//        minApi21 {
//            dimension "api"
//            minSdkVersion 21
//            versionCode 10000 + android.defaultConfig.versionCode
//            versionNameSuffix "-minApi21"
//        }

    }

    //过滤掉所有将“minApi21”和“demo”产品变种组合在一起的 build 变体配置
//    variantFilter { variant ->
//        def names = variant.flavors*.name
//        // To check for a certain build type, use variant.buildType.name == "<buildType>"
//        if (names.contains("minApi21") && names.contains("demo")) {
//            // Gradle ignores any variants that satisfy the conditions above.
//            setIgnore(true)
//        }
//    }

    /**
     * The splits block is where you can configure different APK builds that
     * each contain only code and resources for a supported screen density or
     * ABI. You'll also need to configure your build so that each APK has a
     * different versionCode.
     */
//    splits {
//        // Settings to build multiple APKs based on screen density.
//        density {
//            // Enable or disable building multiple APKs.
//            enable false
//            // Exclude[排除] these densities when building multiple APKs.[屏幕密度]
//            exclude "ldpi", "tvdpi", "xxxhdpi", "400dpi", "560dpi"
//
////            reset()
//            //清空默认的屏幕密度列表。只与 include 元素结合使用以指定您想要添加的密度。
//            // 以下代码段将密度列表设为仅包含 ldpi 和 xxhdpi，方法是先调用 reset() 以清空该列表，然后再使用 include。
//            // Clears the default list from all densities to no densities.
//            // reset()
//            // Specifies the two densities we want to generate APKs for.
//            // include "ldpi", "xxhdpi"
//
//            // Specifies a list of compatible screen size settings for the manifest.[屏幕尺寸]
//            compatibleScreens 'small', 'normal', 'large', 'xlarge'
//        }
//
//        // Configures multiple APKs based on ABI.
//        abi {
//
//            // Enables building multiple APKs per ABI.
//            enable true
//
//            // By default all ABIs are included, so use reset() and include to specify that we only
//            // want APKs for x86 and x86_64.
//
//            // Resets the list of ABIs that Gradle should create APKs for to none.
//            reset()
//
//            // Specifies a list of ABIs that Gradle should create APKs for.
//            include "x86", "x86_64"
//
//            // Specifies that we do not want to also generate a universal APK that includes all ABIs.
//            //如果设为 true，那么除了按 ABI 生成的 APK 之外，Gradle 还会生成一个通用 APK。
//            // 通用 APK 将适用于所有 ABI 的代码和资源包含在一个 APK 中。
//            // 默认值为 false。
//            // 请注意，此选项仅在 splits.abi 代码块中可用。
//            // 根据屏幕密度构建多个 APK 时，Gradle 始终会生成一个包含适用于所有屏幕密度的代码和资源的通用 APK。
//            universalApk false
//        }
//
//    }

    /* sourceSets {
        // Encapsulates[封装] configurations for the main source set.
        // 为变体指定对应的代码集
        main {
            // Changes the directory for Java sources. The default directory is
            // 'src/main/java'.
            java.srcDirs = ['other/java']

            // If you list multiple directories, Gradle uses all of them to collect
            // sources. Because Gradle gives these directories equal priority, if
            // you define the same resource in more than one directory, you get an
            // error when merging resources. The default directory is 'src/main/res'.
            res.srcDirs = ['other/res1', 'other/res2']

            // Note: You should avoid specifying a directory which is a parent to one
            // or more other directories you specify. For example, avoid the following:
            // res.srcDirs = ['other/res1', 'other/res1/layouts', 'other/res1/strings']
            // You should specify either only the root 'other/res1' directory, or only the
            // nested 'other/res1/layouts' and 'other/res1/strings' directories.

            // For each source set, you can specify only one Android manifest.
            // By default, Android Studio creates a manifest for your main source
            // set in the src/main/ directory.
            manifest.srcFile 'other/AndroidManifest.xml'
        }
    } */

    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.10.2"
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = '1.8'
    }
    // 开启viewBinding视图绑定
//    viewBinding {
//        enabled = true
//    }
    // 开启databinding
//    dataBinding {
//        enabled = true
//    }
    // 新版本替换为这个方法进行开启
    buildFeatures{
        dataBinding = true
        // for view binding :
        viewBinding = true
    }
}
//    kapt {
//        generateStubs = true
//    }

//编写编译任务，调用plugin编译生成java文件
protobuf {
    protoc {
        artifact = 'com.google.protobuf:protoc:3.0.0'//编译器版本
    }
    plugins {
        javalite {
            artifact = 'com.google.protobuf:protoc-gen-javalite:3.0.0'//指定当前工程使用的protobuf版本为javalite版，以生成javalite版的java类
        }
    }

    generateProtoTasks.generatedFilesBaseDir = "$projectDir/src/main/java" //指定编译生成java类的存放位置

    generateProtoTasks {
        all().each { task ->
            task.plugins {
                javalite {
                    outputSubDir = '' //指定存放位置的二级目录，这里未指定
                }
            }
        }
    }
}

/**
 * 模块级依赖及第三方库添加
 * The dependencies block in the module-level build configuration file
 * specifies dependencies required to build only the module itself.
 * To learn more, go to Add build dependencies.
 */
dependencies {
    // Dependency on a local library module,
    // 此名称必须与在您的 settings.gradle 文件中使用 include: 定义的库名称相符
    implementation project(":mylibrary")

    // Dependency on local binaries,
    // implementation files('libs/foo.jar', 'libs/bar.jar')
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
//    print("kotlin_version $rootProject.ext.kotlin_version")

    // 全文写法,部分java的库在gayhub中给出的是这种引用写法
    // implementation group: 'com.example.android', name: 'app-magic', version: '12.3'
    implementation 'androidx.core:core-ktx:1.2.0'
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'com.google.android.material:material:1.1.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'

    def fragment_version = "1.3.3"

    // Java language implementation
    implementation "androidx.fragment:fragment:$fragment_version"
    // Kotlin
    implementation "androidx.fragment:fragment-ktx:$fragment_version"

    // To use Jetpack Startup in  library or app,
    implementation "androidx.startup:startup-runtime:1.0.0"

    def work_version = "2.5.0"

    // (Java only)
    implementation "androidx.work:work-runtime:$work_version"

    // Kotlin + coroutines
    implementation "androidx.work:work-runtime-ktx:$work_version"

    // optional - RxJava2 support
    implementation "androidx.work:work-rxjava2:$work_version"

    // optional - GCMNetworkManager support
    implementation "androidx.work:work-gcm:$work_version"

    // optional - Test helpers
    androidTestImplementation "androidx.work:work-testing:$work_version"

    // 如果是用的kotlin 直接用这个好了
    implementation "androidx.datastore:datastore:1.0.0-alpha08"
    implementation "androidx.datastore:datastore-preferences:1.0.0-alpha08"
    //依赖protobuf-lite库
    implementation 'com.google.protobuf:protobuf-lite:3.0.0'


    //https://github.com/elvishew/xLog
    implementation 'com.elvishew:xlog:1.9.0'

    // Adds a remote binary dependency only for local tests.
    testImplementation 'junit:junit:4.+'
    testImplementation 'androidx.test:core-ktx:1.1.0'

    // Adds a remote binary dependency only for the instrumented test APK.
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
//    向指定变体中添加依赖 productFlavorName + 依赖链接
//    demoImplementation 'com.google.firebase:firebase-ads:9.8.0'

    //版本要与gradle版本一致
    kapt  "com.android.databinding:compiler:4.1.3"

    //lifecycle
    def lifecycle_version = "2.3.1"
    def arch_version = "2.1.0"

    // ViewModel
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"
    // LiveData
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version"
    // Lifecycles only (without ViewModel or LiveData)
    implementation "androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version"

    // Saved state module for ViewModel
    implementation "androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version"

    // Jetpack Compose Integration for ViewModel
    implementation "androidx.lifecycle:lifecycle-viewmodel-compose:1.0.0-alpha04"

    // Annotation processor
    kapt "androidx.lifecycle:lifecycle-compiler:$lifecycle_version"
    // alternately - if using Java8, use the following instead of lifecycle-compiler
    implementation "androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"

    // optional - helpers for implementing LifecycleOwner in a Service
    implementation "androidx.lifecycle:lifecycle-service:$lifecycle_version"

    // optional - ProcessLifecycleOwner provides a lifecycle for the whole application process
    implementation "androidx.lifecycle:lifecycle-process:$lifecycle_version"

    // optional - ReactiveStreams support for LiveData
    implementation "androidx.lifecycle:lifecycle-reactivestreams-ktx:$lifecycle_version"

    // optional - Test helpers for LiveData
    testImplementation "androidx.arch.core:core-testing:$arch_version"

    def paging_version = "2.1.2"

    implementation "androidx.paging:paging-runtime:$paging_version" // For Kotlin use paging-runtime-ktx

    // alternatively - without Android dependencies for testing
    testImplementation "androidx.paging:paging-common:$paging_version" // For Kotlin use paging-common-ktx

    // optional - RxJava support
    implementation "androidx.paging:paging-rxjava2:$paging_version" // For Kotlin use paging-rxjava2-ktx

    /* 关键字            用法
    implementation	Gradle 会将依赖项添加到编译类路径，并将依赖项打包到构建输出。不过，当您的模块配置
                    implementation 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。
                    也就是说，其他模块只有在运行时才能使用该依赖项。
                    使用此依赖项配置代替 api 或 compile（已弃用）可以显著缩短构建时间，因为这样可以减少构建
                    系统需要重新编译的模块数。例如，如果 implementation 依赖项更改了其 API，Gradle 只会
                    重新编译该依赖项以及直接依赖于它的模块。大多数应用和测试模块都应使用此配置。
     compileOnly	Gradle 只会将依赖项添加到编译类路径（也就是说，不会将其添加到构建输出）。如果您创建
                    Android 模块时在编译期间需要相应依赖项，但它在运行时可有可无，此配置会很有用。
     annotationProcessor	 如需添加对作为注解处理器的库的依赖，您必须使用 annotationProcessor
                    配置将其添加到注解处理器的类路径。这是因为，使用此配置可以将编译类路径与注释处理器类路径
                    分开，从而提高构建性能。如果 Gradle 在编译类路径上找到注释处理器，则会禁用避免编译功能，
                    这样会对构建时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注释处理器）。

                    如果 JAR 文件包含以下文件，则 Android Gradle 插件会假定依赖项是注释处理器：
                    META-INF/services/javax.annotation.processing.Processor。 如果插件检测到编译类路径
                    上包含注解处理器，则会产生构建错误。

                    注意：Kotlin 项目应使用 kapt 声明注解处理器依赖项。
     */
}